problem,solution
"/**
 * This exercise requires you to design a `Constants` object in Kotlin to store various constant values used in an Android fitness application.
 *
 * @object Constants An object that holds constant values for the application.
 * @property primaryKeyRoutineId The primary key for a routine.
 * @property exerciseId The primary key for an exercise.
 * @property googlePlayUrl The URL for the app's Google Play Store page.
 * @property fileProvider Lazily initialized file provider using the application context.
 * @property maximumNumberOfSets Maximum number of sets allowed.
 * @property preferences* Various keys for storing and retrieving preferences such as routine, weight measurement units, screen settings, etc.
 */
","package com.bodyweight.fitness

object Constants {
    val primaryKeyRoutineId = ""primaryKeyRoutineId""
    val exerciseId = ""exerciseId""

    val googlePlayUrl = ""https://play.google.com/store/apps/details?id=com.bodyweight.fitness.pro""
    val fileProvider: String by lazy {
        App.context!!.getString(R.string.file_provider)
    }

    val maximumNumberOfSets = 12

    val preferencesDefaultRoutineKey = ""PREFERENCE_DEFAULT_ROUTINE""
    val preferencesWeightMeasurementUnitsKey = ""PREFERENCE_WEIGHT_MEASUREMENT_UNITS""
    val preferencesPlaySoundWhenTimerStopsKey = ""PREFERENCE_PLAY_SOUND_WHEN_TIMER_STOPS""
    val preferencesAutomaticallyLogWorkoutTimeKey = ""PREFERENCE_AUTOMATICALLY_LOG_WORKOUT_TIME""
    val preferencesKeepScreenOnKey = ""PREFERENCE_KEEP_SCREEN_ON""
    val preferencesTimerKey = ""PREFERENCE_TIMER_KEY_""
    val preferencesNumberOfRepsKey = ""PREFERENCE_NUMBER_OF_REPS_KEY_""
    val preferencesExerciseIdForSection = ""PREFERENCE_EXERCISE_ID_FOR_SECTION_""
    val preferencesIntroductionShown = ""PREFERENCE_INTRODUCTION_SHOWN""
    val preferencesShowRestTimer = ""PREFERENCE_SHOW_REST_TIMER""
    val preferencesRestTimerDefaultSeconds = ""PREFERENCE_REST_TIMER_DEFAULT_SECONDS""
    val preferencesShowRestTimerAfterWarmup = ""PREFERENCE_SHOW_REST_TIMER_WARMUP_EXERCISES""
    val preferencesShowRestTimerAfterBodylineDrills = ""PREFERENCE_SHOW_REST_TIMER_BODYLINE_DRILLS""
    val preferencesShowRestTimerAfterFlexibilityExercises = ""PREFERENCE_SHOW_REST_TIMER_FLEXIBILITY_ROUTINES""
}"
"/**
 * This exercise requires you to create an `App` class in Kotlin that extends the `Application` class for an Android fitness application.
 *
 * @class App The application class that initializes various libraries and manages the application context.
 * @property context The static context variable used throughout the application.
 * @method onCreate Initializes JodaTime, RateThisApp, and Fabric crash reporting, and sets up the application context.
 */
","package com.bodyweight.fitness

import android.app.Application
import android.content.Context

import com.bodyweight.fitness.repository.SchemaMigration

import com.crashlytics.android.Crashlytics
import com.crashlytics.android.answers.Answers
import com.kobakei.ratethisapp.RateThisApp

import net.danlew.android.joda.JodaTimeAndroid

import io.fabric.sdk.android.Fabric

class App : Application() {
    companion object {
        @JvmStatic
        var context: Context? = null
    }

    override fun onCreate() {
        super.onCreate()

        JodaTimeAndroid.init(applicationContext)

        val config = RateThisApp.Config(2, 7)
        RateThisApp.init(config)

        if (!BuildConfig.DEBUG) {
            Fabric.with(applicationContext, Crashlytics(), Answers())
        }

        context = applicationContext

        SchemaMigration().apply {
            migrateSchemaIfNeeded()
        }
    }
}
"
"/**
 * This exercise requires you to implement utility functions for an Android fitness application to manage UI elements, color resources, and date/time manipulations.
 *
 * @function primary Returns the primary color used in the application.
 * @function primaryDark Returns the darker variant of the primary color.
 * @function calculateLayoutWeight Calculates the layout weight based on the completion rate.
 * @function LinearLayout.setLayoutWeight Sets the layout weight for the LinearLayout.
 * @function Int.toPx Converts a dimension in dp to pixels based on the provided context.
 * @function View.setBackgroundResourceWithPadding Sets the background resource for a view while preserving its padding.
 * @function ViewGroup.inflate Inflates a layout resource into the ViewGroup.
 * @function View.inflate Inflates a layout resource into the View while providing a parent ViewGroup.
 * @function View.setVisible Sets the visibility of the view to VISIBLE.
 * @function View.setInvisible Sets the visibility of the view to INVISIBLE.
 * @function View.setGone Sets the visibility of the view to GONE.
 * @function DateTime.isToday Checks if the DateTime instance represents the current day.
 * @function DateTime.isRoutineLogged Checks if a routine is logged for the given DateTime.
 * @function DateTime.isRoutineLoggedWithResults Retrieves all logged routines for the given DateTime.
 * @function Double.formatWeight Formats a weight value as a string with the appropriate measurement unit.
 * @function Int.formatReps Formats the number of repetitions for display, with an optional postfix.
 * @function Int.formatMinutes Formats an integer value representing seconds into a string representing minutes.
 * @function Int.formatMinutesPostfix Formats an integer representing minutes with a postfix.
 * @function Int.formatMinutesAsNumber Converts seconds to minutes as an integer.
 * @function Int.formatSeconds Formats an integer value representing seconds into a string.
 * @function Int.formatSecondsPostfix Formats an integer representing seconds with a postfix.
 * @function Int.formatSecondsAsNumber Converts seconds to the remaining seconds after minutes are deducted.
 */
","package com.bodyweight.fitness

import android.content.Context
import android.graphics.Color
import android.util.TypedValue
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.LinearLayout

import com.bodyweight.fitness.model.RepositoryRoutine
import com.bodyweight.fitness.repository.Repository
import com.bodyweight.fitness.utils.Preferences

import io.realm.RealmResults
import org.joda.time.DateTime

fun primary(): Int {
    return Color.parseColor(""#009688"")
}

fun primaryDark(): Int {
    return Color.parseColor(""#00453E"")
}

fun calculateLayoutWeight(completionRate: Int): Float {
    if (completionRate <= 10) {
        return 7f
    }

    val weight = completionRate * 0.7f;

    if (weight > 70f) {
        return 70f
    }

    return weight
}

fun LinearLayout.setLayoutWeight(weight: Float) {
    val params = this.layoutParams as LinearLayout.LayoutParams

    params.weight = weight;

    this.layoutParams = params
}

fun Int.toPx(context: Context): Int = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, this.toFloat(), context.resources.displayMetrics).toInt()

fun View.setBackgroundResourceWithPadding(resource: Int) {
    val bottom = paddingBottom
    val top = paddingTop
    val right = paddingRight
    val left = paddingLeft

    setBackgroundResource(resource)
    setPadding(left, top, right, bottom)
}

fun ViewGroup.inflate(layoutRes: Int, attachToRoot: Boolean = false): View {
    return LayoutInflater.from(context).inflate(layoutRes, this, attachToRoot)
}

fun View.inflate(layoutRes: Int, root: ViewGroup, attachToRoot: Boolean = false): View {
    return LayoutInflater.from(context).inflate(layoutRes, root, attachToRoot)
}

fun View.setVisible() {
    this.visibility = View.VISIBLE
}

fun View.setInvisible() {
    this.visibility = View.INVISIBLE
}

fun View.setGone() {
    this.visibility = View.GONE
}

fun DateTime.isToday(): Boolean {
    val now = DateTime()

    return now.year == this.year &&
            now.monthOfYear == this.monthOfYear &&
            now.dayOfMonth == this.dayOfMonth
}

fun DateTime.isRoutineLogged(): Boolean {
    val start = this.withTimeAtStartOfDay()
            .toDate()

    val end = this.withTimeAtStartOfDay()
            .plusDays(1)
            .minusSeconds(1)
            .toDate()

    val realm = Repository.realm
    val routine = realm.where(RepositoryRoutine::class.java)
            .between(""startTime"", start, end)
            .findFirst()

    return routine != null
}

fun DateTime.isRoutineLoggedWithResults(): RealmResults<RepositoryRoutine> {
    val start = this.withTimeAtStartOfDay()
            .toDate()

    val end = this.withTimeAtStartOfDay()
            .plusDays(1)
            .minusSeconds(1)
            .toDate()

    val realm = Repository.realm
    val results: RealmResults<RepositoryRoutine> = realm.where(RepositoryRoutine::class.java)
            .between(""startTime"", start, end)
            .findAll()

    return results
}

fun Double.formatWeight(): String {
    return ""$this ${Preferences.weightMeasurementUnit.asString}""
}

fun Int.formatReps(append: Boolean = false): String {
    if (append) {
        return ""$this x""
    } else {
        if (this == 0) {
            return ""/""
        }

        return this.toString()
    }
}

fun Int.formatMinutes(format: Boolean = true): String {
    val minutes = this / 60

    if (minutes == 0) {
        if (format) {
            return ""00""
        }

        return ""0""
    } else if (minutes < 10) {
        if (format) {
            return ""0"" + minutes
        }

        return minutes.toString()
    }

    return minutes.toString()
}

fun Int.formatMinutesPostfix(): String {
    val minutes = this / 60

    if (minutes == 0) {
        return ""0m""
    }

    return ""${minutes.toString()}m""
}

fun Int.formatMinutesAsNumber(): Int {
    return this / 60
}

fun Int.formatSeconds(format: Boolean = true): String {
    val seconds = this % 60

    if (seconds == 0) {
        if (format) {
            return ""00""
        }

        return ""0""
    } else if (seconds < 10) {
        if (format) {
            return ""0"" + seconds
        }

        return seconds.toString()
    }

    return seconds.toString()
}

fun Int.formatSecondsPostfix(): String {
    val seconds = this % 60

    if (seconds == 0) {
        return ""0s""
    }

    return ""${seconds.toString()}s""
}

fun Int.formatSecondsAsNumber(): Int {
    return this % 60
}"
"/**
 * This exercise requires you to implement a PagerAdapter for managing the progress views in an Android fitness application.
 *
 * @class ProgressPagerAdapter Manages different progress views for a given repository routine.
 * @param repositoryRoutine The routine data containing categories for progress tracking.
 * @function instantiateItem Instantiates a view for a specific page in the ViewPager and adds it to the container.
 * @function destroyItem Removes a view from the ViewPager when it is no longer needed.
 * @function isViewFromObject Checks if the view is associated with the specified object.
 * @function getCount Returns the total number of pages in the ViewPager based on the number of categories.
 * @function getPageTitle Returns the title of the page at the specified position.
 * @function onTabReselected Scrolls the RecyclerView to the top when a tab is reselected.
 * @function onRepositoryUpdated Notifies all adapters of data changes in the repository.
 * @function createRecyclerView Creates and sets up a RecyclerView for displaying progress data for a specific category.
 */
","package com.bodyweight.fitness.adapter

import android.support.v4.view.PagerAdapter
import android.support.v4.view.ViewPager

import android.support.v7.widget.LinearLayoutManager
import android.support.v7.widget.RecyclerView
import android.view.View
import android.view.ViewGroup

import com.bodyweight.fitness.R
import com.bodyweight.fitness.inflate
import com.bodyweight.fitness.model.RepositoryRoutine
import com.bodyweight.fitness.view.progress.ProgressGeneralView
import com.bodyweight.fitness.view.progress.ProgressGeneralViewPresenter

import kotlinx.android.synthetic.main.activity_progress_page.view.*

import java.util.*

class ProgressPagerAdapter(private val repositoryRoutine: RepositoryRoutine) : PagerAdapter() {
    private val viewWeakHashMap = WeakHashMap<Int, RecyclerView>()
    private val adapterList = ArrayList<ProgressListAdapter>()

    override fun instantiateItem(parent: ViewGroup, position: Int): Any {
        val viewPager = parent as ViewPager

        if (position == 0) {
            val view: ProgressGeneralView = parent.inflate(R.layout.activity_progress_general) as ProgressGeneralView
            val presenter: ProgressGeneralViewPresenter = view.presenter as ProgressGeneralViewPresenter

            presenter.repositoryRoutine = repositoryRoutine

            view.updateView()
            viewPager.addView(view)

            return view
        }

        val view = parent.inflate(R.layout.activity_progress_page)

        createRecyclerView(view, position)
        viewPager.addView(view)

        return view
    }

    override fun destroyItem(container: ViewGroup, position: Int, `object`: Any) {
        container.removeView(`object` as View)

        viewWeakHashMap.remove(position)
    }

    override fun isViewFromObject(view: View, `object`: Any): Boolean {
        return view === `object`
    }

    override fun getCount(): Int {
        return repositoryRoutine.categories.size + 1
    }

    override fun getPageTitle(position: Int): CharSequence {
        when (position) {
            0 -> return ""General""
            else -> return repositoryRoutine.categories[position - 1].title!!
        }
    }

    fun onTabReselected(tabPosition: Int) {
        viewWeakHashMap[tabPosition]?.smoothScrollToPosition(0)
    }

    fun onRepositoryUpdated() {
        for (adapter in adapterList) {
            adapter.notifyDataSetChanged()
        }
    }

    private fun createRecyclerView(view: View, position: Int) {
        val repositoryCategory = repositoryRoutine.categories[position - 1]
        val adapter = ProgressListAdapter(repositoryCategory)

        view.recycler_view.layoutManager = LinearLayoutManager(view.context)
        view.recycler_view.adapter = adapter

        viewWeakHashMap.put(position, view.recycler_view)
        adapterList.add(adapter)
    }
}
"
"/**
 * This exercise requires you to implement a RecyclerView Adapter for displaying progress data in an Android fitness application.
 *
 * @class ProgressListAdapter Adapts progress data for a RecyclerView.
 * @param repositoryCategory The category of the repository containing sections and exercises.
 * @function onCreateViewHolder Creates view holders for different types of progress views: Header, Section, and Exercise.
 * @function onBindViewHolder Binds data to the view holders based on their view type.
 * @function getItemCount Returns the total number of items in the adapter.
 * @function getItemViewType Returns the view type for a specific position.
 * @function ProgressHeaderPresenter Binds data to the header view, including completion rates and graphs.
 * @function ProgressCardPresenter Binds data to the exercise card view, including exercise details and actions.
 * @function ProgressTitlePresenter Binds data to the section title view, setting the title and padding.
 */
","package com.bodyweight.fitness.adapter

import android.content.Intent
import android.graphics.Color
import android.support.design.widget.TabLayout
import android.support.v7.widget.RecyclerView
import android.view.View
import android.view.ViewGroup
import com.bodyweight.fitness.*

import com.bodyweight.fitness.model.RepositoryExercise
import com.bodyweight.fitness.model.RepositorySection
import com.bodyweight.fitness.stream.UiEvent
import com.bodyweight.fitness.dialog.LogWorkoutPresenter
import com.bodyweight.fitness.model.*
import com.bodyweight.fitness.repository.Repository
import com.bodyweight.fitness.ui.ProgressExerciseActivity

import com.trello.rxlifecycle.kotlin.bindToLifecycle
import io.realm.Sort

import kotlinx.android.synthetic.main.activity_progress_card.view.*
import kotlinx.android.synthetic.main.activity_progress_card_set.view.*
import kotlinx.android.synthetic.main.activity_progress_header.view.*
import kotlinx.android.synthetic.main.activity_progress_title.view.*
import org.joda.time.DateTime
import rx.android.schedulers.AndroidSchedulers
import java.util.*

enum class ProgressAdapterViewType {
    Header,
    Section,
    Exercise
}

class ProgressListAdapter(private val repositoryCategory: RepositoryCategory) : RecyclerView.Adapter<ProgressPresenter>() {
    private val indexViewTypeHashMap = HashMap<Int, Int>()
    private val indexSectionHashMap = HashMap<Int, RepositorySection>()
    private val indexExerciseHashMap = HashMap<Int, RepositoryExercise>()

    init {
        var index = 0

        indexViewTypeHashMap.put(index, ProgressAdapterViewType.Header.ordinal)

        index += 1

        for (repositorySection in repositoryCategory.sections) {
            indexViewTypeHashMap.put(index, ProgressAdapterViewType.Section.ordinal)
            indexSectionHashMap.put(index, repositorySection)

            index += 1

            for (repositoryExercise in RepositoryRoutine.getVisibleAndCompletedExercises(repositorySection.exercises)) {
                indexViewTypeHashMap.put(index, ProgressAdapterViewType.Exercise.ordinal)
                indexExerciseHashMap.put(index, repositoryExercise)

                index += 1
            }
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ProgressPresenter {
        when (viewType) {
            ProgressAdapterViewType.Header.ordinal -> {
                val view = parent.inflate(R.layout.activity_progress_header)

                return ProgressHeaderPresenter(view)
            }

            ProgressAdapterViewType.Section.ordinal -> {
                val view = parent.inflate(R.layout.activity_progress_title)

                return ProgressTitlePresenter(view)
            }

            else -> {
                val view = parent.inflate(R.layout.activity_progress_card)

                return ProgressCardPresenter(view)
            }
        }
    }

    override fun onBindViewHolder(holder: ProgressPresenter, position: Int) {
        when (indexViewTypeHashMap[position]) {
            ProgressAdapterViewType.Header.ordinal -> {
                val presenter = holder as ProgressHeaderPresenter

                presenter.bindView(repositoryCategory)
            }

            ProgressAdapterViewType.Section.ordinal -> {
                val presenter = holder as ProgressTitlePresenter

                indexSectionHashMap[position]?.let {
                    presenter.bindView(it)
                }
            }

            else -> {
                val presenter = holder as ProgressCardPresenter

                indexExerciseHashMap[position]?.let {
                    presenter.bindView(it)
                }
            }
        }
    }

    override fun getItemCount(): Int {
        return indexViewTypeHashMap.size
    }

    override fun getItemViewType(position: Int): Int {
        return indexViewTypeHashMap[position]!!
    }
}

abstract class ProgressPresenter(itemView: View) : RecyclerView.ViewHolder(itemView)

class ProgressHeaderPresenter(itemView: View) : ProgressPresenter(itemView) {
    var repositoryCategory: RepositoryCategory? = null

    init {
        val completionRateGraphView = itemView.graph_category_completion_rate_view
        val completionRateTabLayout = itemView.graph_category_completion_rate_tablayout

        completionRateGraphView.scrubLineColor = Color.parseColor(""#111111"")
        completionRateGraphView.baseLineColor = Color.WHITE
        completionRateGraphView.isScrubEnabled = true

        completionRateTabLayout.addTab(completionRateTabLayout.newTab().setText(""1W""))
        completionRateTabLayout.addTab(completionRateTabLayout.newTab().setText(""1M""))
        completionRateTabLayout.addTab(completionRateTabLayout.newTab().setText(""3M""))
        completionRateTabLayout.addTab(completionRateTabLayout.newTab().setText(""6M""))
        completionRateTabLayout.addTab(completionRateTabLayout.newTab().setText(""1Y""))
    }

    fun bindView(repositoryCategory: RepositoryCategory) {
        this.repositoryCategory = repositoryCategory

        val numberOfCompletedExercises = RepositoryRoutine.getNumberOfCompletedExercises(repositoryCategory.exercises)
        val numberOfExercises = RepositoryRoutine.getNumberOfExercises(repositoryCategory.exercises)
        val completionRate = RepositoryCategory.getCompletionRate(repositoryCategory)

        itemView.completed_exercises_value.text = ""$numberOfCompletedExercises out of $numberOfExercises""
        itemView.completion_rate_value.text = ""${completionRate.label}""

        val completionRateGraphView = itemView.graph_category_completion_rate_view
        val completionRateTabLayout = itemView.graph_category_completion_rate_tablayout

        val completionRateAdapter = CategoryCompletionRateAdapter()

        completionRateGraphView.adapter = completionRateAdapter
        completionRateGraphView.setScrubListener {
            val dateTimeCompletionRate = it as? CategoryDateTimeCompletionRate

            dateTimeCompletionRate?.let {
                itemView.graph_category_completion_rate_title.text = it.dateTime.toString(""dd MMMM, YYYY"", Locale.ENGLISH)

                if (it.repositoryCategory != null) {
                    val completionRate = RepositoryCategory.getCompletionRate(it.repositoryCategory)

                    itemView.graph_category_completion_rate_description.text = ""${completionRate.label}""
                } else {
                    itemView.graph_category_completion_rate_description.text = ""Not Completed""
                }
            }
        }

        completionRateTabLayout.setOnTabSelectedListener(object : TabLayout.OnTabSelectedListener {
            override fun onTabSelected(tab: TabLayout.Tab) {
                updateCompletionRateTitle()

                when (tab.position) {
                    0 -> updateCompletionRateGraph(completionRateAdapter, 7)
                    1 -> updateCompletionRateGraph(completionRateAdapter, 30)
                    2 -> updateCompletionRateGraph(completionRateAdapter, 90)
                    3 -> updateCompletionRateGraph(completionRateAdapter, 180)
                    else -> updateCompletionRateGraph(completionRateAdapter, 360)
                }
            }

            override fun onTabUnselected(tab: TabLayout.Tab) {

            }

            override fun onTabReselected(tab: TabLayout.Tab) {

            }
        })

        updateCompletionRateGraph(completionRateAdapter, 7)
        updateCompletionRateTitle()
    }

    fun updateCompletionRateTitle() {
        repositoryCategory?.let {
            val completionRate = RepositoryCategory.getCompletionRate(it)

            itemView.graph_category_completion_rate_title.text = DateTime(it.routine!!.startTime).toString(""dd MMMM, YYYY"", Locale.ENGLISH)
            itemView.graph_category_completion_rate_description.text = ""${completionRate.label}""
        }
    }

    fun updateCompletionRateGraph(adapter: CategoryCompletionRateAdapter, minusDays: Int = 7) {
        val start = DateTime.now().withTimeAtStartOfDay().minusDays(minusDays)
        val end = DateTime.now()

        Repository.realm.where(RepositoryRoutine::class.java)
                .between(""startTime"", start.toDate(), end.toDate())
                .findAllAsync()
                .sort(""startTime"", Sort.DESCENDING)
                .asObservable()
                .filter { it.isLoaded }
                .map {
                    val dates = ArrayList<CategoryDateTimeCompletionRate>()

                    for (index in 1..minusDays) {
                        val date = start.plusDays(index)

                        val repositoryCategory: RepositoryCategory? = it.filter {
                            val startTime = DateTime(it.startTime)

                            date.dayOfMonth == startTime.dayOfMonth
                                    && date.monthOfYear == startTime.monthOfYear
                                    && date.year == startTime.year
                        }.firstOrNull()?.categories?.filter {
                            it.categoryId == repositoryCategory?.categoryId
                        }?.firstOrNull()

                        if (repositoryCategory != null) {
                            dates.add(CategoryDateTimeCompletionRate(date, repositoryCategory))
                        } else {
                            dates.add(CategoryDateTimeCompletionRate(date, null))
                        }
                    }

                    dates
                }
                .observeOn(AndroidSchedulers.mainThread())
                .bindToLifecycle(itemView)
                .subscribe {
                    adapter.changeData(it)
                }
    }
}

class ProgressCardPresenter(itemView: View) : ProgressPresenter(itemView) {
    fun bindView(repositoryExercise: RepositoryExercise) {
        itemView.exercise_title.text = repositoryExercise.title
        itemView.exercise_summary.text = LogWorkoutPresenter().getToolbarDescription(repositoryExercise)

        itemView.full_report_button.setOnClickListener {
            val intent = Intent(it.context, ProgressExerciseActivity::class.java)
            intent.putExtra(Constants.exerciseId, repositoryExercise.exerciseId)

            it.context.startActivity(intent)
        }

        itemView.edit_button.setOnClickListener {
            UiEvent.showDialog(DialogType.ProgressActivityLogWorkout, repositoryExercise.exerciseId)
        }

        itemView.exercise_sets.removeAllViews()

        if (RepositoryExercise.isCompleted(repositoryExercise)) {
            itemView.exercise_sets.setVisible()
        } else {
            itemView.exercise_sets.setGone()
        }

        for ((index, repositorySet) in repositoryExercise.sets.withIndex()) {
            val view = itemView.exercise_sets.inflate(R.layout.activity_progress_card_set)

            if (repositorySet.isTimed) {
                val rawSeconds = repositorySet.seconds

                val stringMinutes = rawSeconds.formatMinutes(format = false)
                val numberOfMinutes = rawSeconds.formatMinutesAsNumber()
                val stringSeconds = rawSeconds.formatSeconds(format = false)
                val numberOfSeconds = rawSeconds.formatSecondsAsNumber()

                val minutes = if (numberOfMinutes == 1) { ""Minute"" } else { ""Minutes"" }
                val seconds = if (numberOfSeconds == 1) { ""Second"" } else { ""Seconds"" }

                if (rawSeconds < 60) {
                    view.left_value.text = ""$stringSeconds $seconds""
                } else if (numberOfSeconds == 0 || numberOfSeconds == 60) {
                    view.left_value.text = ""$stringMinutes $minutes""
                } else {
                    view.left_value.text = ""$stringMinutes $minutes, $stringSeconds $seconds""
                }

                view.left_label.text = ""Set ${index + 1}""

                view.right_value.text = """"
                view.right_label.text = """"
            } else {
                val reps = if (repositorySet.reps == 1) { ""Rep"" } else { ""Reps"" }

                view.left_value.text = ""${repositorySet.reps} $reps""
                view.left_label.text = ""Set ${index + 1}""

                if (repositorySet.weight > 0.0) {
                    view.right_value.text = ""${repositorySet.weight}""
                    view.right_label.text = ""Weight""
                } else {
                    view.right_value.text = """"
                    view.right_label.text = """"
                }
            }

            itemView.exercise_sets.addView(view)
        }
    }
}

class ProgressTitlePresenter(itemView: View) : ProgressPresenter(itemView) {
    fun bindView(repositorySection: RepositorySection) {
        if (layoutPosition == 0) {
            itemView.title.setPadding(
                    itemView.title.paddingLeft,
                    itemView.title.paddingLeft,
                    itemView.title.paddingRight,
                    itemView.title.paddingBottom)
        } else {
            itemView.title.setPadding(
                    itemView.title.paddingLeft,
                    itemView.title.paddingBottom,
                    itemView.title.paddingRight,
                    itemView.title.paddingBottom)
        }

        itemView.title.text = repositorySection.title
    }
}
"
"/**
 * This class is responsible for adapting a fitness routine's data for display in a RecyclerView.
 *
 * @class DashboardTreeAdapter Adapts fitness routine data for a RecyclerView.
 * @param routine The fitness routine containing linked exercises, sections, and categories.
 * @param currentExercise The currently selected exercise for highlighting in the list.
 * @function onCreateViewHolder Creates view holders for different types of routine views: Section, Double Item, Category, and Single Item.
 * @function onBindViewHolder Binds data to the view holders based on their view type and handles exercise click events.
 * @function getItemCount Returns the total number of items in the adapter.
 * @function getItemViewType Returns the view type for a specific position in the dashboard tree.
 * @function asObservable Provides an Observable to emit selected exercise events.
 * @class DashboardAbstractPresenter Abstract class for view holders, defining the method to bind data.
 * @class DashboardCategoryPresenter Binds data to the category view, including the category title.
 * @class DashboardSectionPresenter Binds data to the section view, including section title and description.
 * @class DashboardSingleItemPresenter Binds data to the single exercise view, setting the title, level, and button background.
 * @class DashboardDoubleItemPresenter Binds data to the double exercise view, setting titles and button backgrounds for two exercises.
 */
","package com.bodyweight.fitness.adapter

import android.support.v7.widget.RecyclerView
import android.view.View
import android.view.ViewGroup

import com.bodyweight.fitness.R
import com.bodyweight.fitness.inflate
import com.bodyweight.fitness.model.*

import kotlinx.android.synthetic.main.view_dashboard_category.view.*
import kotlinx.android.synthetic.main.view_dashboard_double_item.view.*
import kotlinx.android.synthetic.main.view_dashboard_section.view.*
import kotlinx.android.synthetic.main.view_dashboard_single_item.view.*

import rx.Observable
import rx.subjects.PublishSubject

import java.util.HashMap
import java.util.HashSet

data class Tuple(val left: LinkedRoutine? = null, val right: LinkedRoutine? = null)

class DashboardTreeAdapter(private val routine: Routine, currentExercise: Exercise) : RecyclerView.Adapter<DashboardAbstractPresenter>() {
    private val dashboardTree = HashMap<Int, Tuple>()
    private val exerciseSubject = PublishSubject.create<Exercise>()

    var scrollPosition = 0
        private set

    init {
        var index = 0
        var skip = false

        val categorySet = HashSet<Category>()
        val set = HashSet<Section>()

        var firstInSection: Boolean

        for (exercise in routine.linkedExercises) {
            if (skip) {
                skip = false
            } else {
                val category = exercise.category
                if (!categorySet.contains(category)) {
                    categorySet.add(category!!)

                    dashboardTree.put(index, Tuple(category))

                    index++
                }

                val section = exercise.section
                if (!set.contains(section)) {
                    set.add(section!!)

                    dashboardTree.put(index, Tuple(section))

                    if (section.exercises.contains(currentExercise)) {
                        scrollPosition = index
                    }

                    firstInSection = true

                    index++
                } else {
                    firstInSection = false
                }

                if (exercise.section!!.sectionMode == SectionMode.All
                        && exercise.next != null
                        && exercise!!.next!!.section == exercise.section
                        && !firstInSection) {
                    dashboardTree.put(index, Tuple(exercise, exercise.next))

                    skip = true
                } else {
                    dashboardTree.put(index, Tuple(exercise))
                }

                index++
            }
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): DashboardAbstractPresenter {
        when (viewType) {
            1 -> {
                val view = parent.inflate(R.layout.view_dashboard_section)
                return DashboardSectionPresenter(view)
            }

            2 -> {
                val view = parent.inflate(R.layout.view_dashboard_double_item)
                return DashboardDoubleItemPresenter(view)
            }

            3 -> {
                val view = parent.inflate(R.layout.view_dashboard_category)
                return DashboardCategoryPresenter(view)
            }

            else -> {
                val view = parent.inflate(R.layout.view_dashboard_single_item)
                return DashboardSingleItemPresenter(view)
            }
        }
    }

    override fun onBindViewHolder(holder: DashboardAbstractPresenter, position: Int) {
        holder.onBindView(exerciseSubject, dashboardTree[position]!!)
    }

    override fun getItemCount(): Int {
        return dashboardTree.size
    }

    override fun getItemViewType(position: Int): Int {
        val tuple = dashboardTree[position] as Tuple

        if (tuple.left?.type == RoutineType.Section) {
            return 1
        }

        if (tuple.left?.type == RoutineType.Category) {
            return 3
        }

        if (tuple.right != null) {
            return 2
        }

        return 0
    }

    fun asObservable(): Observable<Exercise> {
        return exerciseSubject.asObservable()
    }
}

abstract class DashboardAbstractPresenter(itemView: View) : RecyclerView.ViewHolder(itemView) {
    abstract fun onBindView(exerciseSubject: PublishSubject<Exercise>, tuple: Tuple)
}

class DashboardCategoryPresenter(itemView: View) : DashboardAbstractPresenter(itemView) {
    override fun onBindView(exerciseSubject: PublishSubject<Exercise>, tuple: Tuple) {
        val category = tuple.left as Category

        itemView.category_title.text = category.title
    }
}

class DashboardSectionPresenter(itemView: View) : DashboardAbstractPresenter(itemView) {
    override fun onBindView(exerciseSubject: PublishSubject<Exercise>, tuple: Tuple) {
        val section = tuple.left as Section

        if (section.sectionMode == SectionMode.All) {
            itemView.section_title.text = section.title
        } else {
            itemView.section_title.text = section.title
        }

        itemView.section_description.text = section.description
    }
}

class DashboardSingleItemPresenter(itemView: View) : DashboardAbstractPresenter(itemView) {
    override fun onBindView(exerciseSubject: PublishSubject<Exercise>, tuple: Tuple) {
        val exercise = tuple.left as Exercise

        if (exercise.isTimedSet) {
            itemView.exercise_button.setBackgroundDrawable(itemView.context.resources.getDrawable(R.drawable.dashboard_circle_timed))
        } else {
            itemView.exercise_button.setBackgroundDrawable(itemView.context.resources.getDrawable(R.drawable.dashboard_circle_weighted))
        }

        if (exercise.section!!.sectionMode == SectionMode.Levels) {
            itemView.exercise_title.text = exercise.title

            itemView.exercise_level.text = String.format(""%s out of %s"", exercise.level, exercise.section!!.exercises.size)
            itemView.exercise_level.visibility = View.VISIBLE
        } else {
            itemView.exercise_title.text = exercise.title
            itemView.exercise_level.visibility = View.GONE
        }

        itemView.exercise_button.setOnClickListener {
            exerciseSubject.onNext(exercise)
        }
    }
}

class DashboardDoubleItemPresenter(itemView: View) : DashboardAbstractPresenter(itemView) {
    override fun onBindView(exerciseSubject: PublishSubject<Exercise>, tuple: Tuple) {
        val leftExercise = tuple.left as Exercise
        val rightExercise = tuple.right as Exercise

        if (leftExercise.isTimedSet) {
            itemView.left_exercise_button.setBackgroundDrawable(itemView.context.resources.getDrawable(R.drawable.dashboard_circle_timed))
        } else {
            itemView.left_exercise_button.setBackgroundDrawable(itemView.context.resources.getDrawable(R.drawable.dashboard_circle_weighted))
        }

        if (rightExercise.isTimedSet) {
            itemView.right_exercise_button.setBackgroundDrawable(itemView.context.resources.getDrawable(R.drawable.dashboard_circle_timed))
        } else {
            itemView.right_exercise_button.setBackgroundDrawable(itemView.context.resources.getDrawable(R.drawable.dashboard_circle_weighted))
        }

        itemView.left_exercise_title.text = leftExercise.title
        itemView.right_exercise_title.text = rightExercise.title

        itemView.left_exercise_button.setOnClickListener {
            exerciseSubject.onNext(leftExercise)
        }

        itemView.right_exercise_button.setOnClickListener {
            exerciseSubject.onNext(rightExercise)
        }
    }
}"
"/**
 * This class adapts rep data for display in a Spark chart within a fitness application.
 *
 * @class RepsAdapter Adapts rep data for a Spark chart.
 * @function changeData Updates the adapter with a new list of DateTimeRepositorySet data and notifies the dataset change.
 * @function getCount Returns the total number of items in the adapter.
 * @function getItem Returns the item at a specified index.
 * @function getY Returns the Y value (reps) for a specific index.
 * @function getX Returns the X value (index) for a specific index.
 * @function hasBaseLine Indicates whether a baseline exists for the chart.
 * @function getBaseLine Returns the baseline value for the chart.
 */

/**
 * This class adapts time data for display in a Spark chart within a fitness application.
 *
 * @class TimeAdapter Adapts time data for a Spark chart.
 * @function changeData Updates the adapter with a new list of DateTimeRepositorySet data and notifies the dataset change.
 * @function getCount Returns the total number of items in the adapter.
 * @function getItem Returns the item at a specified index.
 * @function getY Returns the Y value (seconds) for a specific index.
 * @function getX Returns the X value (index) for a specific index.
 * @function hasBaseLine Indicates whether a baseline exists for the chart.
 * @function getBaseLine Returns the baseline value for the chart.
 */

/**
 * This class adapts workout length data for display in a Spark chart within a fitness application.
 *
 * @class WorkoutLengthAdapter Adapts workout length data for a Spark chart.
 * @function changeData Updates the adapter with a new list of DateTimeWorkoutLength data and notifies the dataset change.
 * @function getCount Returns the total number of items in the adapter.
 * @function getItem Returns the item at a specified index.
 * @function getY Returns the Y value (workout length in minutes) for a specific index.
 * @function getX Returns the X value (index) for a specific index.
 * @function hasBaseLine Indicates whether a baseline exists for the chart.
 * @function getBaseLine Returns the baseline value for the chart.
 */

/**
 * This class adapts category completion rate data for display in a Spark chart within a fitness application.
 *
 * @class CategoryCompletionRateAdapter Adapts category completion rate data for a Spark chart.
 * @function changeData Updates the adapter with a new list of CategoryDateTimeCompletionRate data and notifies the dataset change.
 * @function getCount Returns the total number of items in the adapter.
 * @function getItem Returns the item at a specified index.
 * @function getY Returns the Y value (completion rate percentage) for a specific index.
 * @function getX Returns the X value (index) for a specific index.
 * @function hasBaseLine Indicates whether a baseline exists for the chart.
 * @function getBaseLine Returns the baseline value for the chart.
 */

/**
 * This class adapts overall completion rate data for display in a Spark chart within a fitness application.
 *
 * @class CompletionRateAdapter Adapts overall completion rate data for a Spark chart.
 * @function changeData Updates the adapter with a new list of DateTimeCompletionRate data and notifies the dataset change.
 * @function getCount Returns the total number of items in the adapter.
 * @function getItem Returns the item at a specified index.
 * @function getY Returns the Y value (completion rate percentage) for a specific index.
 * @function getX Returns the X value (index) for a specific index.
 * @function hasBaseLine Indicates whether a baseline exists for the chart.
 * @function getBaseLine Returns the baseline value for the chart.
 */
","package com.bodyweight.fitness.adapter

import com.bodyweight.fitness.model.*
import com.robinhood.spark.SparkAdapter

import java.util.*

class RepsAdapter : SparkAdapter() {
    private var data: ArrayList<DateTimeRepositorySet>? = null

    fun changeData(data: ArrayList<DateTimeRepositorySet>) {
        this.data = data

        notifyDataSetChanged()
    }

    override fun getCount(): Int {
        data?.let {
            return it.size
        }

        return 0
    }

    override fun getItem(index: Int): Any {
        val item = data?.getOrNull(index)

        item?.let {
            return it
        }

        return """"
    }

    override fun getY(index: Int): Float {
        data?.getOrNull(index)?.repositorySet?.let {
            return it.reps.toFloat()
        }

        return 0f
    }

    override fun getX(index: Int): Float {
        return index.toFloat()
    }

    override fun hasBaseLine(): Boolean {
        return true
    }

    override fun getBaseLine(): Float {
        return 15f
    }
}

class TimeAdapter : SparkAdapter() {
    private var data: ArrayList<DateTimeRepositorySet>? = ArrayList()

    fun changeData(data: ArrayList<DateTimeRepositorySet>) {
        this.data = data

        notifyDataSetChanged()
    }

    override fun getCount(): Int {
        data?.let {
            return it.size
        }

        return 0
    }

    override fun getItem(index: Int): Any {
        val item = data?.getOrNull(index)

        item?.let {
            return it
        }

        return """"
    }

    override fun getY(index: Int): Float {
        data?.getOrNull(index)?.repositorySet?.let {
            return it.seconds.toFloat()
        }

        return 0f
    }

    override fun getX(index: Int): Float {
        return index.toFloat()
    }

    override fun hasBaseLine(): Boolean {
        return true
    }

    override fun getBaseLine(): Float {
        return 120f
    }
}

class WorkoutLengthAdapter : SparkAdapter() {
    private var data = ArrayList<DateTimeWorkoutLength>()

    fun changeData(data: ArrayList<DateTimeWorkoutLength>) {
        this.data = data

        notifyDataSetChanged()
    }

    override fun getCount(): Int {
        return data.size
    }

    override fun getItem(index: Int): Any {
        val item = data.getOrNull(index)

        item?.let {
            return it
        }

        return """"
    }

    override fun getY(index: Int): Float {
        data[index].repositoryRoutine?.let {
            return RepositoryRoutine.getWorkoutLengthInMinutes(it).toFloat()
        }

        return 0f
    }

    override fun getX(index: Int): Float {
        return index.toFloat()
    }

    override fun hasBaseLine(): Boolean {
        return true
    }

    override fun getBaseLine(): Float {
        return 60.0f
    }
}

class CategoryCompletionRateAdapter : SparkAdapter() {
    private var data = ArrayList<CategoryDateTimeCompletionRate>()

    fun changeData(data: ArrayList<CategoryDateTimeCompletionRate>) {
        this.data = data

        notifyDataSetChanged()
    }

    override fun getCount(): Int {
        return data.size
    }

    override fun getItem(index: Int): Any {
        val item = data.getOrNull(index)

        item?.let {
            return it
        }

        return """"
    }

    override fun getY(index: Int): Float {
        data[index].repositoryCategory?.let {
            return RepositoryCategory.getCompletionRate(it).percentage.toFloat()
        }

        return 0f
    }

    override fun getX(index: Int): Float {
        return index.toFloat()
    }

    override fun hasBaseLine(): Boolean {
        return true
    }

    override fun getBaseLine(): Float {
        return 100.0f
    }
}

class CompletionRateAdapter : SparkAdapter() {
    private var data = ArrayList<DateTimeCompletionRate>()

    fun changeData(data: ArrayList<DateTimeCompletionRate>) {
        this.data = data

        notifyDataSetChanged()
    }

    override fun getCount(): Int {
        return data.size
    }

    override fun getItem(index: Int): Any {
        val item = data.getOrNull(index)

        item?.let {
            return it
        }

        return """"
    }

    override fun getY(index: Int): Float {
        data[index].repositoryRoutine?.let {
            return RepositoryRoutine.getCompletionRate(it).percentage.toFloat()
        }

        return 0f
    }

    override fun getX(index: Int): Float {
        return index.toFloat()
    }

    override fun hasBaseLine(): Boolean {
        return true
    }

    override fun getBaseLine(): Float {
        return 100.0f
    }
}"
"/**
 * This class adapts a list of routines for display in a spinner within a fitness application.
 *
 * @class SpinnerRoutine Represents a routine with an ID, title, and subtitle.
 * @class ToolbarSpinnerAdapter Adapts routine data for a spinner view.
 * @property routines A list of SpinnerRoutine items available for selection in the spinner.
 *
 * @constructor Initializes the adapter with routines based on the current routine ID from RoutineStream.
 * @function getCount Returns the total number of routines in the adapter.
 * @function getItem Returns the routine item at a specified position.
 * @function getItemId Returns the ID for the routine item at a specified position.
 * @function getDropDownView Creates and returns the dropdown view for displaying routine titles.
 * @function getView Creates and returns the view for displaying the selected routine title in the spinner.
 * @function getTitle Retrieves the title of the routine at a specified position.
 */
","package com.bodyweight.fitness.adapter

import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.BaseAdapter
import android.widget.TextView

import com.bodyweight.fitness.R
import com.bodyweight.fitness.stream.RoutineStream

data class SpinnerRoutine(val id: Int, val title: String, val subtitle: String)

class ToolbarSpinnerAdapter : BaseAdapter() {
    val routines: List<SpinnerRoutine>

    init {
        val routineId = RoutineStream.routine.routineId

        if (routineId == ""routine0"") {
            routines = listOf(
                    SpinnerRoutine(0, ""Bodyweight Fitness"", ""Recommended Routine""),
                    SpinnerRoutine(1, ""Starting Stretching"", ""Flexibility Routine""),
                    SpinnerRoutine(2, ""Molding Mobility"", ""Flexibility Routine"")
            )
        } else if (routineId == ""e73593f4-ee17-4b9b-912a-87fa3625f63d"") {
            routines = listOf(
                    SpinnerRoutine(2, ""Molding Mobility"", ""Flexibility Routine""),
                    SpinnerRoutine(0, ""Bodyweight Fitness"", ""Recommended Routine""),
                    SpinnerRoutine(1, ""Starting Stretching"", ""Flexibility Routine"")
            )
        } else if (routineId == ""d8a722a0-fae2-4e7e-a751-430348c659fe"") {
            routines = listOf(
                    SpinnerRoutine(1, ""Starting Stretching"", ""Flexibility Routine""),
                    SpinnerRoutine(0, ""Bodyweight Fitness"", ""Recommended Routine""),
                    SpinnerRoutine(2, ""Molding Mobility"", ""Flexibility Routine"")
            )
        } else {
            routines = listOf(
                    SpinnerRoutine(0, ""Bodyweight Fitness"", ""Recommended Routine""),
                    SpinnerRoutine(1, ""Starting Stretching"", ""Flexibility Routine""),
                    SpinnerRoutine(2, ""Molding Mobility"", ""Flexibility Routine"")
            )
        }
    }

    override fun getCount(): Int {
        return routines.size
    }

    override fun getItem(position: Int): Any {
        return routines[position]
    }

    override fun getItemId(position: Int): Long {
        return position.toLong()
    }

    override fun getDropDownView(position: Int, view: View?, parent: ViewGroup): View {
        var view = view
        if (view == null || view.tag.toString() != ""DROPDOWN"") {

            view = LayoutInflater.from(parent.context).inflate(R.layout.toolbar_spinner_item_dropdown, parent, false)
            view.tag = ""DROPDOWN""
        }

        val textView: TextView = view!!.findViewById(android.R.id.text1)
        textView.text = getTitle(position)

        return view
    }

    override fun getView(position: Int, view: View?, parent: ViewGroup): View {
        var view = view

        if (view == null || view.tag.toString() != ""NON_DROPDOWN"") {
            view = LayoutInflater.from(parent.context).inflate(R.layout.toolbar_spinner_item_actionbar, parent, false)
            view.tag = ""NON_DROPDOWN""
        }

        return view!!
    }

    private fun getTitle(position: Int): String {
        return routines[position].title
    }
}"
"/**
 * This class adapts a list of routines for display in a calendar within a fitness application.
 *
 * @class CalendarListAdapter Adapts repository routines for a RecyclerView in the calendar view.
 * @property repositoryRoutineList A list of repository routines fetched from the database.
 *
 * @function setItems Updates the adapter with a new list of repository routines and notifies changes.
 * @function onCreateViewHolder Creates and returns a CalendarRoutinePresenter for each item in the RecyclerView.
 * @function onBindViewHolder Binds data to the CalendarRoutinePresenter based on the position.
 * @function getItemCount Returns the total number of routines in the adapter.
 * @function getItemViewType Returns the view type for a specific item (default is 0).
 */
 
/**
 * This class presents a single calendar routine item in the RecyclerView.
 *
 * @class CalendarRoutinePresenter Represents a view holder for displaying a repository routine in the calendar.
 * @property calendarListAdapter A reference to the CalendarListAdapter for accessing its methods.
 *
 * @function onBindView Binds data to the view, including routine title, subtitle, and completion rate.
 * @function setOnClickListener Sets up click listeners for various actions: viewing progress, exporting logs, and removing workouts.
 * @function exportWorkoutLog Exports the workout log as a CSV file and initiates sharing.
 * @function removeWorkout Displays a confirmation dialog for removing the logged workout from the database.
 */
","package com.bodyweight.fitness.adapter

import android.content.Intent
import android.support.v4.content.FileProvider
import android.support.v7.app.AlertDialog
import android.support.v7.widget.RecyclerView
import android.view.View
import android.view.ViewGroup
import android.widget.Toast

import com.bodyweight.fitness.*
import com.bodyweight.fitness.model.RepositoryRoutine
import com.bodyweight.fitness.repository.Repository
import com.bodyweight.fitness.stream.Stream
import com.bodyweight.fitness.ui.ProgressActivity

import io.realm.RealmResults

import kotlinx.android.synthetic.main.view_calendar_card.view.*

import java.io.File
import java.io.FileOutputStream

class CalendarListAdapter : RecyclerView.Adapter<CalendarRoutinePresenter>() {
    private var repositoryRoutineList: RealmResults<RepositoryRoutine>? = null

    fun setItems(results: RealmResults<RepositoryRoutine>) {
        repositoryRoutineList = results

        notifyDataSetChanged()
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): CalendarRoutinePresenter {
        val view = parent.inflate(R.layout.view_calendar_card)

        return CalendarRoutinePresenter(view)
    }

    override fun onBindViewHolder(presenter: CalendarRoutinePresenter, position: Int) {
        repositoryRoutineList?.let {
            presenter.calendarListAdapter = this
            presenter.onBindView(it[position])
        }
    }

    override fun getItemCount(): Int = repositoryRoutineList?.size ?: 0
    override fun getItemViewType(position: Int): Int = 0
}

class CalendarRoutinePresenter(itemView: View) : RecyclerView.ViewHolder(itemView) {
    var calendarListAdapter: CalendarListAdapter? = null

    fun onBindView(repositoryRoutine: RepositoryRoutine) {
        itemView.view_calendar_routine_title.text = repositoryRoutine.title
        itemView.view_calendar_routine_subtitle.text = repositoryRoutine.subtitle

        val completionRate = RepositoryRoutine.getCompletionRate(repositoryRoutine)

        itemView.completion_rate_label.text = completionRate.label
        itemView.completion_rate_value.setLayoutWeight(calculateLayoutWeight(completionRate.percentage))

        itemView.view_calendar_card_view_button.setOnClickListener {
            val intent = Intent(it.context, ProgressActivity::class.java)
            intent.putExtra(Constants.primaryKeyRoutineId, repositoryRoutine.id)

            it.context.startActivity(intent)
        }

        itemView.view_calendar_card_export_button.setOnClickListener {
            val intent = Intent(it.context, ProgressActivity::class.java)
            intent.putExtra(Constants.primaryKeyRoutineId, repositoryRoutine.id)

            it.context.startActivity(intent)
        }

        itemView.view_calendar_card_export_button.setOnClickListener {
            val context = it.context

            try {
                val path = File(context.filesDir, ""csv"");
                val file = File(path, ""LoggedWorkout.csv"").apply {
                    if (parentFile.mkdirs()) {
                        createNewFile()
                    }
                }

                FileOutputStream(file).apply {
                    write(RepositoryRoutine.toCSV(repositoryRoutine).toByteArray())
                    flush()
                    close()
                }

                context.startActivity(Intent().apply {
                    action = Intent.ACTION_SEND
                    type = ""text/plain""
                    flags = Intent.FLAG_GRANT_READ_URI_PERMISSION

                    putExtra(Intent.EXTRA_TITLE, RepositoryRoutine.getTitleWithDate(repositoryRoutine))
                    putExtra(Intent.EXTRA_TEXT, RepositoryRoutine.toText(repositoryRoutine))
                    putExtra(Intent.EXTRA_STREAM, FileProvider.getUriForFile(context, Constants.fileProvider, file))
                })
            } catch (e: Exception) {
                e.printStackTrace()

                Toast.makeText(context, ""Error: Unable to export workout log"", Toast.LENGTH_SHORT).show()
            }
        }

        itemView.view_calendar_card_remove_button.setOnClickListener {
            AlertDialog.Builder(it.context)
                    .setTitle(""Remove Logged Workout?"")
                    .setPositiveButton(""Ok"") { dialog, which ->
                        val realm = Repository.realm

                        realm.executeTransaction {
                            repositoryRoutine.deleteFromRealm()
                        }

                        Stream.setRepository()
                    }
                    .setNegativeButton(""Cancel"") { dialog, which ->  }
                    .show()
        }
    }
}
"
"/**
 * This class adapts calendar pages for a ViewPager in a fitness application.
 *
 * @class CalendarPagerAdapter Adapts calendar pages for swiping functionality in a ViewPager.
 *
 * @property DEFAULT_POSITION The default number of pages in the ViewPager (set to 60).
 *
 * @function instantiateItem Creates and initializes a new calendar page view for the specified position.
 * @function destroyItem Removes the calendar page view from the ViewPager when no longer needed.
 * @function isViewFromObject Checks whether a view is associated with a specific object.
 * @function getCount Returns the total number of pages in the ViewPager (DEFAULT_POSITION + 1).
 */
","package com.bodyweight.fitness.adapter

import android.support.v4.view.PagerAdapter

import android.view.View
import android.view.ViewGroup

import com.bodyweight.fitness.view.CalendarPagePresenter
import com.bodyweight.fitness.view.CalendarPageView
import com.bodyweight.fitness.view.widget.ViewPager

import com.bodyweight.fitness.R
import com.bodyweight.fitness.inflate

class CalendarPagerAdapter : PagerAdapter() {
    companion object {
        val DEFAULT_POSITION = 60
    }

    override fun instantiateItem(viewGroup: ViewGroup, position: Int): Any {
        val viewPager = viewGroup as ViewPager

        val calendarPageView = viewGroup.inflate(R.layout.view_calendar_page) as CalendarPageView
        val calendarPagePresenter = calendarPageView.presenter as CalendarPagePresenter

        calendarPagePresenter.viewPagerPosition = position
        calendarPageView.updateView()

        viewPager.addView(calendarPageView)

        return calendarPageView
    }

    override fun destroyItem(container: ViewGroup, position: Int, `object`: Any) {
        container.removeView(`object` as View)
    }

    override fun isViewFromObject(view: View, `object`: Any): Boolean {
        return view === `object`
    }

    override fun getCount(): Int {
        return DEFAULT_POSITION + 1
    }
}
"
